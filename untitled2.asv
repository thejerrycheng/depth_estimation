% Point CLoud 3D Plane Fitting 
clear all;
clc; 


%% Loading the point cloud file:

data = load('point_cloud.mat');
point_cloud = data.point_cloud;

% visualize the point cloud data:

% Assuming extracted_point_cloud is your point cloud data
x = point_cloud(:, 1);  % X coordinates
y = point_cloud(:, 2);  % Y coordinates
z = point_cloud(:, 3);  % Z coordinates

% Create a 3D scatter plot
scatter3(x, y, z, 3);  % '3' here sets the marker size

% Label the axes
xlabel('X-axis');
ylabel('Y-axis');
zlabel('Z-axis');

% Optionally, you can add grid, title or change other plot properties
grid on;
title('3D Point Cloud Visualization');

%% Here is the point cloud 3D plane fitting

ptCloud = pointCloud(point_cloud);  % Convert to pointCloud object

maxDistance = 0.02;  % Maximum distance of points to plane for them to be considered inliers
referenceVector = [0, 0, 1];  % A reference vector to guide the orientation of the plane

% Example loop to fit multiple planes
numPlanes = 10;  % Set the number of planes you want to fit
planes = cell(numPlanes, 1);  % Cell array to store plane models
% for i = 1:numPlanes
%     [model, inlierIndices] = pcfitplane(ptCloud, maxDistance, referenceVector);
%     if isempty(model)
%         break;  % Exit if no more planes can be fitted
%     end
%     planes{i} = model;
%     % Assuming you have a point cloud 'ptCloud' and a set of inlier indices 'inlierIndices'
%     remainingIndices = true(ptCloud.Count, 1);  % Create a logical array of 'true' values
%     remainingIndices(inlierIndices) = false;    % Set the inliers to 'false'
%     
%     % Now select the remaining points
%     ptCloud = select(ptCloud, remainingIndices);  % This should match the size of the point cloud
% end
% numPlanes = 5;  % Set the number of planes you want to fit
% planes = cell(numPlanes, 1);  % Cell array to store plane models
% numFittedPlanes = 0;
% [model, inlierIndices] = pcfitplane(ptCloud, maxDistance, referenceVector);
% normalPrevious = model.Parameters(1:3);
% % for i = 1:numPlanes
% while numFittedPlanes < 5
%     [model, inlierIndices] = pcfitplane(ptCloud, maxDistance, referenceVector);
%     % Extract the normal vector for the current plane
%     normalCurrent = model.Parameters(1:3);
% 
%     % Check if a plane was found
%     if isempty(model)
%         break;  % Exit if no more planes can be fitted
%     end
%     % Calculate the angle between the current plane and previous planes
%     isNewPlane = true;
%     for j = 1:numPlanes
%         normalPrevious = model.Parameters(1:3);
%         angle = acosd(dot(normalCurrent, normalPrevious) / (norm(normalCurrent) * norm(normalPrevious)));
%         if angle < 30 || angle > 150 % Check if the angle is less than 30 or more than 150 degrees
%             distance = abs(dot(normalCurrent, planes{j}.Parameters(1:3)) + planes{j}.Parameters(4)) / norm(normalCurrent);
%                 if distance < 100  % Check if the/ distance is less than 100 units
%                     isNewPlane = false;
%                     break;
%                 end 
% 
%         end
%     end
%     
%     % If the plane is sufficiently different, add it to the list
%     if isNewPlane
%         numFittedPlanes = numFittedPlanes + 1;
%         planes{numFittedPlanes} = model;
% 
% %         ptCloud = select(ptCloud, ~inlierIndices);  % Remove inliers for next iteration
% % Assuming you have a point cloud 'ptCloud' and a set of inlier indices 'inlierIndices'
%         remainingIndices = true(ptCloud.Count, 1);  % Create a logical array of 'true' values
%         remainingIndices(inlierIndices) = false;    % Set the inliers to 'false'
%         
%         % Now select the remaining points
%         ptCloud = select(ptCloud, remainingIndices);  % This should match the size of the point cloud
%         disp("The distance to the previous fitted plane is: ")
% %         disp(dist)
%         fprintf(distance)
%         disp("The angle to the previous fitted plane is: ")
% %         disp(angle)
%         fprintf(angle)
%     end
% end
% 
% % Trim the cell array if fewer planes were fitted
% planes = planes(1:numFittedPlanes);

numPlanes = 3;  % Number of planes to fit
planes = cell(numPlanes, 1);  % Cell array to store plane models
numFittedPlanes = 0;

for i = 1:numPlanes
    [model, inlierIndices, ~] = pcfitplane(ptCloud, maxDistance, referenceVector);
    
    % Check if a plane was found
    if isempty(model)
        break;  % Exit if no more planes can be fitted
    end

    % Extract the normal vector for the current plane
    normalCurrent = model.Parameters(1:3);

    % Check the angle with previous planes
    isNewPlane = true;
    for j = 1:numFittedPlanes
        normalPrevious = planes{j}.Parameters(1:3);
        angle = acosd(dot(normalCurrent, normalPrevious) / (norm(normalCurrent) * norm(normalPrevious)));
        
        if angle < 30 || angle > 150  % Check the angle
            distance = abs(dot(normalCurrent, planes{j}.Parameters(1:3)) + planes{j}.Parameters(4)) / norm(normalCurrent);
            if distance < 100  % Check the distance
                isNewPlane = false;
                break;
            end
        end
    end

    % Add the plane if it is sufficiently different
    if isNewPlane
        numFittedPlanes = numFittedPlanes + 1;
        planes{numFittedPlanes} = model;
        ptCloud = select(ptCloud, ~inlierIndices);  % Remove inliers for next iteration
    end
end

planes = planes(1:numFittedPlanes);  % Trim the cell array



figure;
pcshow(ptCloud);
hold on;

for i = 1:length(planes)
    model = planes{i};
    plot(model)
    % You can plot the plane model using `plot(model)` or other visualization techniques
    % This might involve creating a meshgrid and evaluating the plane equation
end

xlabel('X');
ylabel('Y');
zlabel('Z');
title('Point Cloud with Fitted Planes');
hold off;
